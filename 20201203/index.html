<!DOCTYPE html>
<html lang="ja">
	<head>
		<meta charset="utf-8">
		<link rel="Stylesheet" href="css/main.css">
		<title>20201203内容</title>
	</head>
	<body>
		<div class="container">
			<h1>継承の基礎</h1>
			<h2>継承とは</h2>
			<p><b>以前作成したクラスと似通ったクラスを作成する際に使用する。</b></p>
			<p>コピペをして解決する方法では、<b>追加、修正にコストがかかる</b>そのため、継承を行う</p>
			<p><b>extends</b>…継承する際にクラス宣言につける</p>
			<p><b>public class クラス名 extends 継承元のクラス名{親クラスとの差分メンバ}</b></p>
			<p><b>extendsを用いることによって、元のクラスとの差分だけを記述して新たなクラスを宣言することができる。</b></p>
			<p>継承の元となるクラスを<b>スーパークラス、基底クラス、親クラスなどと呼ぶ。</b></p>
			<p>継承されたクラスを<b>子クラス、サブクラス、派生クラスなどと呼ぶ</b></p>
			<p><b>javaは多重継承できない！！</b>・・・多重継承とは複数のクラスを親として一つの子クラスを作ること。</b></p>
			<h3>オーバーライド</h3>
			<p><b>オーバーライド(override)</b>・・・親クラスを継承して子クラスを宣言する際、子クラスで親クラスのメンバを上書きすること</p>
			<p><b>オーバーライドする際は@Overrideアノテーションをつける！！(バグチェック)</b></p>
			<p>クラス名に<b>final</b>をつけた場合<b>継承禁止のクラスとなる</b></p>
			<p><b>public final class クラス名</b></p>
			<p><b>宣言時にfinalがつけられたメソッドは、子クラスでオーバーライドできない</b></p>
			<p><b>public final void メソッド名{}</b>…オーバーライド不可</p>
			<p><b>フィールドはオーバーライドしない！！！</b></p>
			<h3>インスタンスの多重構造</h3>
			<p><b>Heroインスタンスから生まれたSuperHeroインスタンスは、Heroインスタンスを含んでおり二重構造となっている</b></p>
			<p>二重構造、三重構造となっている場合、外からメソッドが呼び出された際<b>極力外側にある子インスタンス部分のメソッドで対応しようとする</b></p>
			<p><b>super.メソッド名</b>…親インスタンス部分のメソッドを呼び出す。</p>
			<p><b>super</b>・・・とは今より一つ内側のインスタンス部分を指す。</p>
			<h4>親インスタンス部分のフィールドを利用する</h4>
			<p><b>super.フィールド名</b></p>
			<h4>親インスタンス部分のメソッドを呼び出す</h4>
			<p><b>super.メソッド名</b>…親インスタンスのメソッドを呼び出す。</p>
			<p><b>親の親クラスへのアクセスは不可!!</b></p>
			<p><b>全てのコンストラクタは、その先頭で必ず内部インスタンス部分（親クラス）のコンストラクタを呼び出さなければならない</b></p>
			<p>呼び出し方</p>
			<p><b>super(引数);</b>
			<code><pre>
			public SuperHero(){
				super();
				・・・
			}
			</code></pre>
			<p>もし書き忘れた場合<b>自動的にsuper()が挿入されるが、親インスタンスのコンストラクタに引数が必要だった場合はコンパイルエラー！！</b></p>
			<h3>is-aの原則</h3>
			<p><b>A is-a Bとなるように化粧は定義する。</b>・・・<b>aはbの一種である</b>というニュアンス</p>
			<h4>汎化、特化の関係</h4>
			<p><b>特化</b>・・・子クラスになるほど具体的なものに具体化(特化)していくこと。</p>
			<p><b>汎化</b>・・・親クラスになるほど抽象的であいまいなものに一般化していくこと。
			<h2>高度な継承</h2>
			<p><b>別の開発者が将来利用するであろうクラスを作っておく</b></p>
			<h2>抽象クラス</h2>
			<p><b>public abstract 戻り値　メソッド名(引数);</b>で宣言する。<b>;を忘れない！！！</b></p>
			<p><b>public abstract class クラス名{}</b>・・・javaではabstractメソッドを含むクラスは必ずクラス宣言時に<b>abstractクラスとして宣言しなければならない</b></p>
			<p><b>抽象クラスはnewによるインスタンス化が禁止される</b></p>
			<p><b>抽象クラスとした場合抽象メソッドを子クラスでオーバーライドしていないとエラーが表示されて実行できない</b></p>
			<p><b>逆に抽象メソッドを継承してそのまま抽象メソッドとして残す場合は、子クラスも抽象クラスにしなければならない</b></p>
			<p><b>実装(implements)する</b>・・・それまで抽象メソッドだった処理を確定させること。</p>
			<h2>インタフェース</h2>
			<p><b>interface(インタフェース)</b>・・・特に抽象度の高い上流のクラス</p>
			<h3>インタフェースの条件</h3>
			<p><b>全てのメソッドは抽象メソッドである。</b></p>
			<p><b>基本的にフィールドを一つも持たない</b></p>
			<p><b>public interface インタフェース{}</b>・・・でインタフェース宣言</p>
			<p><b>インタフェース内のメソッドはpublic abstractを省略可</b></p>
			<p><b>インタフェース内で宣言が許されるフィールドは定数のみ！！！</b></p>
			<p>ex:<b>public static final double PI =3.14159</b>等</p>
			<p><b>implements</b>・・・インタフェースを継承して子クラスを定義する場合に使う。<b>インタフェースを実装するという</b></p>
			<p><b>public class クラス名 implements インタフェース名{}</b></p>
			<p><b>インタフェースは多重継承できる！！</b></p>
			<p><b>public class クラス名 implements 親インタフェース1,親インタフェース2,親インタフェース3・・・{}</b></p>
			<p><b>インタフェースを継承してインタフェースを作成する場合、implementsではなくextendsを使う!</b></p>
			<p><b>何かを実装しているわけではなく、インタフェースの機能を拡張しているだけだから。</b></p>
			<p><b>extendsとimplementsを両方使ったクラスの定義</b></p>
			<p><b>public class クラス名 extends 親クラス implements 親インタフェース1,親インタフェース2・・・{}</b></p>
			<h3>デフォルト実装付き抽象メソッドの宣言</h3>
			<p><b>もし継承先でインタフェースのメソッドがオーバーライドされなかった場合、自動的にデフォルト実装として定めた処理内容でオーバーライドされたものとみなされる。</b></p>
			<p><b>default 戻り値 メソッド名(引数){処理のデフォルト実装}</b></p>
			<h2>関数、単語等</h2>
			<p><b>extends</b>…拡張する、広げる</p>
			<p><b>abstract</b>・・・抽象的な、理論的な、観念的な</p>
			<h2>特記</h2>
		</div>
	</body>
</html>
